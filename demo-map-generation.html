<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Map Generation Demo - Command & Conquer Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: #fff;
            min-height: 100vh;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            text-align: center;
            border-bottom: 2px solid #e74c3c;
        }

        .header h1 {
            color: #e74c3c;
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 1rem;
            padding: 1rem;
            min-height: calc(100vh - 120px);
        }

        .sidebar {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .main-content {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
        }

        .controls-section {
            margin-bottom: 1.5rem;
        }

        .controls-section h3 {
            color: #e74c3c;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .control-group {
            margin-bottom: 1rem;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.25rem;
            font-size: 0.9rem;
            color: #bdc3c7;
        }

        .control-group select,
        .control-group input[type="number"],
        .control-group input[type="range"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.9rem;
        }

        .control-group input[type="range"] {
            padding: 0;
        }

        .range-value {
            font-size: 0.8rem;
            color: #95a5a6;
            margin-top: 0.25rem;
        }

        .button {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: #fff;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: bold;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        .button:hover {
            background: linear-gradient(135deg, #c0392b, #a93226);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .button.secondary {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .button.secondary:hover {
            background: linear-gradient(135deg, #2980b9, #1f618d);
        }

        .map-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .map-title {
            color: #e74c3c;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .map-info {
            font-size: 0.9rem;
            color: #bdc3c7;
        }

        .map-canvas-container {
            flex: 1;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            min-height: 400px;
            background: #2c3e50;
        }

        #mapCanvas {
            width: 100%;
            height: 100%;
            display: block;
            image-rendering: pixelated;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #e74c3c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .stats-section {
            margin-top: 1rem;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem;
            border-radius: 4px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #e74c3c;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #bdc3c7;
        }

        .validation-results {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .validation-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }

        .validation-pass {
            color: #2ecc71;
        }

        .validation-fail {
            color: #e74c3c;
        }

        .validation-warning {
            color: #f39c12;
        }

        .examples-section {
            margin-bottom: 1.5rem;
        }

        .preset-button {
            background: linear-gradient(135deg, #27ae60, #229954);
            margin-bottom: 0.25rem;
            font-size: 0.8rem;
            padding: 0.5rem;
        }

        .preset-button:hover {
            background: linear-gradient(135deg, #229954, #1e8449);
        }

        .workflow-section {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #f39c12);
            width: 0%;
            transition: width 0.3s ease;
        }

        .log-section {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            padding: 1rem;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            margin-top: 1rem;
        }

        .log-entry {
            margin-bottom: 0.25rem;
            padding: 0.25rem;
            border-left: 3px solid #3498db;
            padding-left: 0.5rem;
        }

        .log-entry.error {
            border-left-color: #e74c3c;
            color: #e74c3c;
        }

        .log-entry.success {
            border-left-color: #2ecc71;
            color: #2ecc71;
        }

        .log-entry.warning {
            border-left-color: #f39c12;
            color: #f39c12;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 250px 1fr 250px;
            }
        }

        @media (max-width: 992px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Advanced Map Generation Demo</h1>
        <p>Interactive demonstration of the Command & Conquer clone map generation system</p>
    </div>

    <div class="container">
        <!-- Left Sidebar - Generation Controls -->
        <div class="sidebar">
            <div class="controls-section">
                <h3>Map Configuration</h3>
                
                <div class="control-group">
                    <label for="mapWidth">Map Width:</label>
                    <input type="number" id="mapWidth" value="40" min="20" max="100">
                </div>
                
                <div class="control-group">
                    <label for="mapHeight">Map Height:</label>
                    <input type="number" id="mapHeight" value="30" min="20" max="100">
                </div>
                
                <div class="control-group">
                    <label for="playerCount">Players:</label>
                    <select id="playerCount">
                        <option value="2">2 Players</option>
                        <option value="4">4 Players</option>
                        <option value="6">6 Players</option>
                        <option value="8">8 Players</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="algorithm">Algorithm:</label>
                    <select id="algorithm">
                        <option value="wfc">Wave Function Collapse</option>
                        <option value="symmetric">Symmetric</option>
                        <option value="hybrid" selected>Hybrid</option>
                        <option value="classic">Classic</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="climate">Climate:</label>
                    <select id="climate">
                        <option value="temperate" selected>Temperate</option>
                        <option value="desert">Desert</option>
                        <option value="arctic">Arctic</option>
                        <option value="volcanic">Volcanic</option>
                    </select>
                </div>
            </div>

            <div class="controls-section">
                <h3>Terrain Settings</h3>
                
                <div class="control-group">
                    <label for="mountainDensity">Mountain Density:</label>
                    <input type="range" id="mountainDensity" min="0" max="0.3" step="0.05" value="0.15">
                    <div class="range-value" id="mountainDensityValue">0.15</div>
                </div>
                
                <div class="control-group">
                    <label for="waterCoverage">Water Coverage:</label>
                    <input type="range" id="waterCoverage" min="0" max="0.3" step="0.05" value="0.1">
                    <div class="range-value" id="waterCoverageValue">0.10</div>
                </div>
                
                <div class="control-group">
                    <label for="forestDensity">Forest Density:</label>
                    <input type="range" id="forestDensity" min="0" max="0.2" step="0.025" value="0.05">
                    <div class="range-value" id="forestDensityValue">0.05</div>
                </div>
                
                <div class="control-group">
                    <label for="resourceDensity">Resource Density:</label>
                    <input type="range" id="resourceDensity" min="0.02" max="0.15" step="0.01" value="0.08">
                    <div class="range-value" id="resourceDensityValue">0.08</div>
                </div>
            </div>

            <div class="examples-section">
                <h3>Quick Presets</h3>
                <button class="button preset-button" data-preset="tournament">Tournament 1v1</button>
                <button class="button preset-button" data-preset="teamgame">Team Game 2v2</button>
                <button class="button preset-button" data-preset="ffa">Free-for-All</button>
                <button class="button preset-button" data-preset="campaign">Campaign Style</button>
            </div>

            <button class="button" id="generateBtn">Generate Map</button>
            <button class="button secondary" id="exportBtn" disabled>Export Map</button>
        </div>

        <!-- Main Content - Map Display -->
        <div class="main-content">
            <div class="map-header">
                <div class="map-title" id="mapTitle">Map Preview</div>
                <div class="map-info" id="mapInfo">No map generated</div>
            </div>
            
            <div class="map-container">
                <div class="map-canvas-container">
                    <canvas id="mapCanvas" width="800" height="600"></canvas>
                    <div class="loading-overlay hidden" id="loadingOverlay">
                        <div class="spinner"></div>
                        <div>Generating map...</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="log-section" id="logSection">
                <div class="log-entry">Ready to generate maps. Select your parameters and click "Generate Map".</div>
            </div>
        </div>

        <!-- Right Sidebar - Stats and Validation -->
        <div class="sidebar">
            <div class="stats-section">
                <h3>Generation Stats</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="statGenTime">-</div>
                        <div class="stat-label">Generation Time (ms)</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statQuality">-</div>
                        <div class="stat-label">Quality Score</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statTiles">-</div>
                        <div class="stat-label">Tile Types</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="statResources">-</div>
                        <div class="stat-label">Resource Fields</div>
                    </div>
                </div>
            </div>

            <div class="validation-results" id="validationResults">
                <h3>Map Validation</h3>
                <div id="validationList">
                    <div class="validation-item">
                        <span>Generate a map to see validation results</span>
                    </div>
                </div>
            </div>

            <div class="workflow-section">
                <h3>Workflow Tools</h3>
                <button class="button secondary" id="analyzeBtn" disabled>Analyze Patterns</button>
                <button class="button secondary" id="optimizeBtn" disabled>Optimize Map</button>
                <button class="button secondary" id="validateBtn" disabled>Re-validate</button>
                
                <div style="margin-top: 1rem;">
                    <button class="button" id="runWorkflowBtn">Run Complete Workflow</button>
                    <p style="font-size: 0.8rem; color: #bdc3c7; margin-top: 0.5rem;">
                        Runs the full OpenRA extraction to map generation pipeline
                    </p>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Mock implementation of the map generation system for demo purposes
        // In a real implementation, this would import the actual mapgen modules

        class MockMapGenerator {
            constructor() {
                this.tileColors = {
                    'S01': '#D2B48C', 'S02': '#DEB887', 'S03': '#F4A460', 'S04': '#DAA520',
                    'S05': '#CD853F', 'S06': '#D2691E', 'S07': '#A0522D', 'S08': '#8B4513',
                    'D01': '#8B4513', 'D02': '#A0522D', 'D03': '#CD853F', 'D04': '#D2691E',
                    'D05': '#DEB887', 'D06': '#F4A460', 'D07': '#DAA520', 'D08': '#B8860B',
                    'W1': '#4682B4', 'W2': '#5F9EA0',
                    'SH1': '#708090', 'SH2': '#778899', 'SH3': '#696969',
                    'SH4': '#808080', 'SH5': '#A9A9A9', 'SH6': '#C0C0C0',
                    'T01': '#228B22', 'T02': '#32CD32', 'T03': '#9ACD32', 'T04': '#6B8E23',
                    'T05': '#556B2F', 'T06': '#8FBC8F', 'T07': '#90EE90', 'T08': '#98FB98', 'T09': '#00FF7F',
                    'ROCK1': '#696969', 'ROCK2': '#708090', 'ROCK3': '#778899', 'ROCK4': '#2F4F4F',
                    'ROCK5': '#483D8B', 'ROCK6': '#6A5ACD', 'ROCK7': '#9370DB',
                    'TI1': '#00FF00', 'TI2': '#32CD32', 'TI3': '#7CFC00',
                    'TI10': '#0000FF', 'TI11': '#4169E1', 'TI12': '#6495ED'
                };
            }

            async generateMap(config) {
                const { width, height, playerCount, algorithm, climate } = config;
                const startTime = Date.now();

                // Simulate generation delay
                await this.simulateProgress();

                const terrain = this.generateTerrain(width, height, climate, algorithm);
                const resources = this.generateResources(width, height, terrain);
                const startingPositions = this.generateStartingPositions(width, height, playerCount);
                
                const generationTime = Date.now() - startTime;
                const validation = this.validateMap(terrain, resources, startingPositions);

                return {
                    name: `${algorithm} ${width}x${height} ${playerCount}P`,
                    width,
                    height,
                    playerCount,
                    algorithm,
                    terrain,
                    resources,
                    startingPositions,
                    metadata: {
                        generationTime,
                        climate,
                        tileTypes: Object.keys(this.getUsedTiles(terrain)).length
                    },
                    validation
                };
            }

            async simulateProgress() {
                const progressFill = document.getElementById('progressFill');
                let progress = 0;
                
                while (progress < 100) {
                    progress += Math.random() * 15 + 5;
                    progress = Math.min(progress, 100);
                    progressFill.style.width = `${progress}%`;
                    await new Promise(resolve => setTimeout(resolve, 50 + Math.random() * 100));
                }
            }

            generateTerrain(width, height, climate, algorithm) {
                const terrain = [];
                
                for (let y = 0; y < height; y++) {
                    terrain[y] = [];
                    for (let x = 0; x < width; x++) {
                        terrain[y][x] = this.generateTerrainTile(x, y, width, height, climate, algorithm);
                    }
                }
                
                return terrain;
            }

            generateTerrainTile(x, y, width, height, climate, algorithm) {
                const centerX = width / 2;
                const centerY = height / 2;
                const distFromCenter = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                const maxDist = Math.sqrt(centerX ** 2 + centerY ** 2);
                const normalizedDist = distFromCenter / maxDist;
                
                const noise = this.simpleNoise(x * 0.1, y * 0.1);
                const rand = Math.random();

                let baseTile;
                switch (climate) {
                    case 'desert':
                        if (normalizedDist < 0.3 + noise * 0.2) {
                            baseTile = `S0${Math.floor(rand * 8) + 1}`;
                        } else if (normalizedDist < 0.6) {
                            baseTile = `D0${Math.floor(rand * 8) + 1}`;
                        } else if (rand < 0.1) {
                            baseTile = `ROCK${Math.floor(rand * 7) + 1}`;
                        } else {
                            baseTile = `S0${Math.floor(rand * 8) + 1}`;
                        }
                        break;
                    
                    case 'arctic':
                        if (normalizedDist < 0.4 + noise * 0.3) {
                            baseTile = `S0${Math.floor(rand * 4) + 1}`;
                        } else if (rand < 0.2) {
                            baseTile = rand < 0.1 ? 'W1' : 'W2';
                        } else {
                            baseTile = `D0${Math.floor(rand * 4) + 1}`;
                        }
                        break;
                    
                    case 'volcanic':
                        if (normalizedDist < 0.2) {
                            baseTile = `S0${Math.floor(rand * 8) + 1}`;
                        } else if (rand < 0.3) {
                            baseTile = `ROCK${Math.floor(rand * 7) + 1}`;
                        } else {
                            baseTile = `D0${Math.floor(rand * 8) + 1}`;
                        }
                        break;
                    
                    default: // temperate
                        if (normalizedDist < 0.3 + noise * 0.2) {
                            baseTile = `S0${Math.floor(rand * 8) + 1}`;
                        } else if (normalizedDist < 0.6) {
                            baseTile = rand < 0.3 ? `T0${Math.floor(rand * 9) + 1}` : `D0${Math.floor(rand * 8) + 1}`;
                        } else if (rand < 0.15) {
                            baseTile = rand < 0.05 ? 'W1' : (rand < 0.1 ? 'W2' : `SH${Math.floor(rand * 6) + 1}`);
                        } else if (rand < 0.25) {
                            baseTile = `ROCK${Math.floor(rand * 7) + 1}`;
                        } else {
                            baseTile = `D0${Math.floor(rand * 8) + 1}`;
                        }
                }

                return baseTile;
            }

            simpleNoise(x, y) {
                return (Math.sin(x * 12.9898) * Math.cos(y * 78.233) * 43758.5453) % 1;
            }

            generateResources(width, height, terrain) {
                const resources = [];
                const resourceCount = Math.floor(width * height * 0.08);
                
                for (let i = 0; i < resourceCount; i++) {
                    const x = Math.floor(Math.random() * width);
                    const y = Math.floor(Math.random() * height);
                    
                    // Only place on buildable terrain
                    if (terrain[y][x].startsWith('S') || terrain[y][x].startsWith('D')) {
                        resources.push({
                            x, y,
                            type: Math.random() > 0.8 ? 'blue' : 'green',
                            amount: Math.floor(Math.random() * 1000) + 500
                        });
                    }
                }
                
                return resources;
            }

            generateStartingPositions(width, height, playerCount) {
                const positions = [];
                const centerX = width / 2;
                const centerY = height / 2;
                const radius = Math.min(width, height) * 0.35;
                
                for (let i = 0; i < playerCount; i++) {
                    const angle = (i / playerCount) * 2 * Math.PI;
                    const x = Math.floor(centerX + Math.cos(angle) * radius);
                    const y = Math.floor(centerY + Math.sin(angle) * radius);
                    
                    positions.push({ x, y, playerId: i + 1 });
                }
                
                return positions;
            }

            validateMap(terrain, resources, startingPositions) {
                const totalTiles = terrain.length * terrain[0].length;
                const buildableTiles = terrain.flat().filter(tile => 
                    tile.startsWith('S') || tile.startsWith('D')
                ).length;
                
                const buildablePercentage = buildableTiles / totalTiles;
                const resourceBalance = this.calculateResourceBalance(resources, startingPositions);
                
                const validation = {
                    accessibility: { allReachable: true, score: 100 },
                    buildable: { percentage: buildablePercentage, valid: buildablePercentage >= 0.6 },
                    resources: { balanced: resourceBalance > 0.7, balance: resourceBalance },
                    startingPositions: { valid: startingPositions.length >= 2, fairness: 0.85 },
                    overall: { score: 0, grade: 'A', valid: true }
                };
                
                validation.overall.score = Math.floor(
                    (validation.accessibility.score * 0.3) +
                    (validation.buildable.percentage * 100 * 0.25) +
                    (validation.resources.balance * 100 * 0.25) +
                    (validation.startingPositions.fairness * 100 * 0.2)
                );
                
                if (validation.overall.score >= 90) validation.overall.grade = 'A';
                else if (validation.overall.score >= 80) validation.overall.grade = 'B';
                else if (validation.overall.score >= 70) validation.overall.grade = 'C';
                else if (validation.overall.score >= 60) validation.overall.grade = 'D';
                else validation.overall.grade = 'F';
                
                validation.overall.valid = validation.overall.score >= 60;
                
                return validation;
            }

            calculateResourceBalance(resources, startingPositions) {
                if (resources.length === 0 || startingPositions.length === 0) return 0;
                
                const playerResources = startingPositions.map(pos => {
                    return resources.reduce((sum, resource) => {
                        const distance = Math.sqrt((resource.x - pos.x) ** 2 + (resource.y - pos.y) ** 2);
                        return sum + (distance < 15 ? resource.amount : 0);
                    }, 0);
                });
                
                const avgResources = playerResources.reduce((a, b) => a + b, 0) / playerResources.length;
                const variance = playerResources.reduce((sum, resources) => 
                    sum + Math.pow(resources - avgResources, 2), 0) / playerResources.length;
                
                return Math.max(0, 1 - (Math.sqrt(variance) / avgResources));
            }

            getUsedTiles(terrain) {
                const used = {};
                terrain.flat().forEach(tile => used[tile] = true);
                return used;
            }

            renderMap(terrain, resources, startingPositions, canvas) {
                const ctx = canvas.getContext('2d');
                const width = terrain[0].length;
                const height = terrain.length;
                
                canvas.width = width * 8;
                canvas.height = height * 8;
                
                // Clear canvas
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Render terrain
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        const tile = terrain[y][x];
                        ctx.fillStyle = this.tileColors[tile] || '#888888';
                        ctx.fillRect(x * 8, y * 8, 8, 8);
                    }
                }
                
                // Render resources
                resources.forEach(resource => {
                    ctx.fillStyle = resource.type === 'blue' ? '#0000FF' : '#00FF00';
                    ctx.fillRect(resource.x * 8, resource.y * 8, 8, 8);
                    
                    // Add glow effect
                    const gradient = ctx.createRadialGradient(
                        resource.x * 8 + 4, resource.y * 8 + 4, 0,
                        resource.x * 8 + 4, resource.y * 8 + 4, 12
                    );
                    gradient.addColorStop(0, resource.type === 'blue' ? 'rgba(0,0,255,0.8)' : 'rgba(0,255,0,0.8)');
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(resource.x * 8 - 4, resource.y * 8 - 4, 16, 16);
                });
                
                // Render starting positions
                startingPositions.forEach((pos, index) => {
                    ctx.fillStyle = '#FF0000';
                    ctx.fillRect(pos.x * 8 - 2, pos.y * 8 - 2, 12, 12);
                    
                    // Add player number
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText((index + 1).toString(), pos.x * 8 + 4, pos.y * 8 + 6);
                });
            }
        }

        // Application state
        let currentMapData = null;
        const mapGenerator = new MockMapGenerator();

        // DOM elements
        const generateBtn = document.getElementById('generateBtn');
        const exportBtn = document.getElementById('exportBtn');
        const mapCanvas = document.getElementById('mapCanvas');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const logSection = document.getElementById('logSection');

        // Range input handlers
        ['mountainDensity', 'waterCoverage', 'forestDensity', 'resourceDensity'].forEach(id => {
            const input = document.getElementById(id);
            const valueDiv = document.getElementById(id + 'Value');
            input.addEventListener('input', () => {
                valueDiv.textContent = parseFloat(input.value).toFixed(2);
            });
        });

        // Preset handlers
        document.querySelectorAll('.preset-button').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                applyPreset(preset);
                logMessage(`Applied ${preset} preset`, 'success');
            });
        });

        // Main generation handler
        generateBtn.addEventListener('click', async () => {
            await generateMap();
        });

        // Export handler
        exportBtn.addEventListener('click', () => {
            if (currentMapData) {
                exportMap(currentMapData);
            }
        });

        // Workflow buttons
        document.getElementById('runWorkflowBtn').addEventListener('click', async () => {
            await runCompleteWorkflow();
        });

        document.getElementById('analyzeBtn').addEventListener('click', () => {
            if (currentMapData) {
                analyzePatterns(currentMapData);
            }
        });

        document.getElementById('optimizeBtn').addEventListener('click', async () => {
            if (currentMapData) {
                await optimizeMap(currentMapData);
            }
        });

        document.getElementById('validateBtn').addEventListener('click', () => {
            if (currentMapData) {
                validateCurrentMap();
            }
        });

        function applyPreset(preset) {
            const presets = {
                tournament: {
                    width: 60, height: 60, players: 2, algorithm: 'symmetric',
                    climate: 'temperate', mountain: 0.1, water: 0.05, forest: 0.03, resource: 0.06
                },
                teamgame: {
                    width: 80, height: 60, players: 4, algorithm: 'hybrid',
                    climate: 'temperate', mountain: 0.15, water: 0.1, forest: 0.08, resource: 0.08
                },
                ffa: {
                    width: 100, height: 80, players: 8, algorithm: 'wfc',
                    climate: 'desert', mountain: 0.2, water: 0.05, forest: 0.02, resource: 0.1
                },
                campaign: {
                    width: 50, height: 40, players: 2, algorithm: 'classic',
                    climate: 'volcanic', mountain: 0.25, water: 0.15, forest: 0.05, resource: 0.12
                }
            };

            const config = presets[preset];
            if (config) {
                document.getElementById('mapWidth').value = config.width;
                document.getElementById('mapHeight').value = config.height;
                document.getElementById('playerCount').value = config.players;
                document.getElementById('algorithm').value = config.algorithm;
                document.getElementById('climate').value = config.climate;
                document.getElementById('mountainDensity').value = config.mountain;
                document.getElementById('waterCoverage').value = config.water;
                document.getElementById('forestDensity').value = config.forest;
                document.getElementById('resourceDensity').value = config.resource;

                // Update value displays
                document.getElementById('mountainDensityValue').textContent = config.mountain.toFixed(2);
                document.getElementById('waterCoverageValue').textContent = config.water.toFixed(2);
                document.getElementById('forestDensityValue').textContent = config.forest.toFixed(2);
                document.getElementById('resourceDensityValue').textContent = config.resource.toFixed(2);
            }
        }

        async function generateMap() {
            const config = {
                width: parseInt(document.getElementById('mapWidth').value),
                height: parseInt(document.getElementById('mapHeight').value),
                playerCount: parseInt(document.getElementById('playerCount').value),
                algorithm: document.getElementById('algorithm').value,
                climate: document.getElementById('climate').value,
                mountainDensity: parseFloat(document.getElementById('mountainDensity').value),
                waterCoverage: parseFloat(document.getElementById('waterCoverage').value),
                forestDensity: parseFloat(document.getElementById('forestDensity').value),
                resourceDensity: parseFloat(document.getElementById('resourceDensity').value)
            };

            showLoading(true);
            generateBtn.disabled = true;

            try {
                logMessage(`Generating ${config.algorithm} map (${config.width}x${config.height})...`, 'info');
                
                currentMapData = await mapGenerator.generateMap(config);
                
                // Update display
                updateMapDisplay(currentMapData);
                updateStats(currentMapData);
                updateValidation(currentMapData.validation);
                
                logMessage(`Map generated successfully in ${currentMapData.metadata.generationTime}ms`, 'success');
                
                exportBtn.disabled = false;
                document.getElementById('analyzeBtn').disabled = false;
                document.getElementById('optimizeBtn').disabled = false;
                document.getElementById('validateBtn').disabled = false;

            } catch (error) {
                logMessage(`Generation failed: ${error.message}`, 'error');
            } finally {
                showLoading(false);
                generateBtn.disabled = false;
            }
        }

        function updateMapDisplay(mapData) {
            document.getElementById('mapTitle').textContent = mapData.name;
            document.getElementById('mapInfo').textContent = 
                `${mapData.width}x${mapData.height} | ${mapData.playerCount} players | Quality: ${mapData.validation.overall.score}/100`;

            mapGenerator.renderMap(
                mapData.terrain, 
                mapData.resources, 
                mapData.startingPositions, 
                mapCanvas
            );
        }

        function updateStats(mapData) {
            document.getElementById('statGenTime').textContent = mapData.metadata.generationTime;
            document.getElementById('statQuality').textContent = mapData.validation.overall.score;
            document.getElementById('statTiles').textContent = mapData.metadata.tileTypes;
            document.getElementById('statResources').textContent = mapData.resources.length;
        }

        function updateValidation(validation) {
            const validationList = document.getElementById('validationList');
            validationList.innerHTML = '';

            const checks = [
                { name: 'Accessibility', result: validation.accessibility.allReachable },
                { name: 'Buildable Area', result: validation.buildable.valid },
                { name: 'Resource Balance', result: validation.resources.balanced },
                { name: 'Starting Positions', result: validation.startingPositions.valid },
                { name: 'Overall Quality', result: validation.overall.valid }
            ];

            checks.forEach(check => {
                const item = document.createElement('div');
                item.className = 'validation-item';
                
                const status = check.result ? 'validation-pass' : 'validation-fail';
                const icon = check.result ? '✓' : '✗';
                
                item.innerHTML = `
                    <span>${check.name}</span>
                    <span class="${status}">${icon}</span>
                `;
                validationList.appendChild(item);
            });
        }

        async function runCompleteWorkflow() {
            logMessage('Starting complete workflow simulation...', 'info');
            showLoading(true);

            try {
                // Simulate workflow steps
                const steps = [
                    'Extracting OpenRA assets...',
                    'Analyzing map patterns...',
                    'Training WFC system...',
                    'Generating multiple maps...',
                    'Validating map quality...',
                    'Optimizing maps...',
                    'Exporting for game use...'
                ];

                for (let i = 0; i < steps.length; i++) {
                    logMessage(steps[i], 'info');
                    await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));
                    
                    const progress = ((i + 1) / steps.length) * 100;
                    document.getElementById('progressFill').style.width = `${progress}%`;
                }

                logMessage('Complete workflow finished! Generated 12 maps, exported 8 high-quality maps.', 'success');

            } catch (error) {
                logMessage(`Workflow failed: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        function analyzePatterns(mapData) {
            logMessage('Analyzing map patterns...', 'info');
            
            setTimeout(() => {
                const patterns = Math.floor(Math.random() * 50) + 20;
                const features = Math.floor(Math.random() * 15) + 5;
                logMessage(`Found ${patterns} unique patterns and ${features} terrain features`, 'success');
            }, 1000);
        }

        async function optimizeMap(mapData) {
            logMessage('Optimizing map quality...', 'info');
            showLoading(true);

            try {
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Simulate optimization
                mapData.validation.overall.score = Math.min(100, mapData.validation.overall.score + Math.floor(Math.random() * 10) + 5);
                
                updateValidation(mapData.validation);
                updateStats(mapData);
                
                logMessage(`Map optimized! New quality score: ${mapData.validation.overall.score}`, 'success');

            } catch (error) {
                logMessage(`Optimization failed: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        function validateCurrentMap() {
            if (!currentMapData) return;
            
            logMessage('Re-validating map...', 'info');
            
            setTimeout(() => {
                currentMapData.validation = mapGenerator.validateMap(
                    currentMapData.terrain,
                    currentMapData.resources,
                    currentMapData.startingPositions
                );
                
                updateValidation(currentMapData.validation);
                updateStats(currentMapData);
                
                logMessage('Map validation complete', 'success');
            }, 500);
        }

        function exportMap(mapData) {
            const exportData = {
                id: mapData.name.toLowerCase().replace(/\s+/g, '-'),
                name: mapData.name,
                width: mapData.width,
                height: mapData.height,
                playerCount: mapData.playerCount,
                terrain: mapData.terrain,
                resources: mapData.resources,
                startingPositions: mapData.startingPositions,
                metadata: {
                    algorithm: mapData.algorithm,
                    generated: new Date().toISOString(),
                    quality: mapData.validation.overall,
                    version: '1.0.0'
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${exportData.id}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            logMessage(`Map exported as ${exportData.id}.json`, 'success');
        }

        function showLoading(show) {
            loadingOverlay.classList.toggle('hidden', !show);
            if (!show) {
                document.getElementById('progressFill').style.width = '0%';
            }
        }

        function logMessage(message, type = 'info') {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            
            logSection.appendChild(logEntry);
            logSection.scrollTop = logSection.scrollHeight;

            // Keep only last 20 messages
            while (logSection.children.length > 20) {
                logSection.removeChild(logSection.firstChild);
            }
        }

        // Initialize
        logMessage('Map Generation Demo initialized. Ready to generate maps!', 'success');
    </script>
</body>
</html>