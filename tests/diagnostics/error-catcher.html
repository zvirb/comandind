<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Security Headers -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'self'; form-action 'self';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Error Monitor - Command and Independent Thought</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: monospace;
            background: #1a1a1a;
            color: #0f0;
        }
        .error-list {
            background: #000;
            padding: 10px;
            border: 1px solid #f00;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .error { color: #f00; margin: 10px 0; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .timestamp { color: #888; }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: monospace;
        }
        button:hover { background: #0a0; }
        .status { color: #0ff; }
    </style>
</head>
<body>
    <h1>üõ°Ô∏è Secure Error Monitor</h1>
    <p class="status">This page captures errors with XSS protection, rate limiting, and secure storage.</p>
    
    <div>
        <button onclick="clearErrors()">Clear Errors</button>
        <button onclick="startGame()">Start Game</button>
        <button onclick="refreshErrors()">Refresh</button>
    </div>
    
    <h2>Captured Errors:</h2>
    <div id="errorList" class="error-list"></div>
    
    <script type="module">
        // Import secure error handler
        let secureErrorHandler = null;
        try {
            const module = await import('/src/utils/SecureErrorHandler.js');
            secureErrorHandler = module.secureErrorHandler;
            console.log('üõ°Ô∏è Secure error handler loaded');
        } catch (e) {
            console.warn('Secure error handler not available:', e);
        }
        
        /**
         * Sanitize text to prevent XSS attacks
         */
        function sanitizeText(text) {
            if (!text) return '';
            
            const div = document.createElement('div');
            div.textContent = String(text);
            return div.innerHTML;
        }
        
        /**
         * Sanitize stack trace and remove sensitive information
         */
        function sanitizeStack(stack) {
            if (!stack) return 'No stack trace';
            
            let sanitized = sanitizeText(stack);
            
            // Remove sensitive file paths
            sanitized = sanitized.replace(/\/home\/[^\/]+/g, '[HOME]');
            sanitized = sanitized.replace(/\/Users\/[^\/]+/g, '[HOME]');
            sanitized = sanitized.replace(/C:\\Users\\[^\\]+/g, '[HOME]');
            
            // Truncate if too long
            const lines = sanitized.split('\n');
            if (lines.length > 8) {
                sanitized = lines.slice(0, 8).join('\n') + '\n[Truncated for security]';
            }
            
            return sanitized;
        }
        
        function clearErrors() {
            if (secureErrorHandler) {
                secureErrorHandler.clearErrors();
            } else {
                // Fallback: clear legacy storage
                const keys = Object.keys(localStorage).filter(key => key.includes('error'));
                keys.forEach(key => localStorage.removeItem(key));
            }
            refreshErrors();
        }
        
        function refreshErrors() {
            const errorList = document.getElementById('errorList');
            
            // Clear existing content safely
            while (errorList.firstChild) {
                errorList.removeChild(errorList.firstChild);
            }
            
            let errors = [];
            
            if (secureErrorHandler) {
                errors = secureErrorHandler.getErrors(30); // Get last 30 errors
            } else {
                // Fallback to check various storage keys
                try {
                    const sources = ['secure_errors_data', 'commandind_errors', 'emergency_errors'];
                    sources.forEach(source => {
                        const stored = localStorage.getItem(source);
                        if (stored) {
                            const parsed = JSON.parse(stored);
                            if (source === 'secure_errors_data' && parsed.errors) {
                                errors = errors.concat(parsed.errors);
                            } else if (Array.isArray(parsed)) {
                                errors = errors.concat(parsed);
                            }
                        }
                    });
                } catch (e) {
                    console.warn('Error loading fallback errors:', e);
                }
            }
            
            if (errors.length === 0) {
                const noErrorsDiv = document.createElement('div');
                noErrorsDiv.style.color = '#0f0';
                noErrorsDiv.textContent = '‚úÖ No errors captured - System is secure!';
                errorList.appendChild(noErrorsDiv);
                return;
            }
            
            // Sort by timestamp (newest first)
            errors.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            errors.forEach((error, index) => {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'error';
                
                // Timestamp
                const timestampDiv = document.createElement('div');
                timestampDiv.className = 'timestamp';
                timestampDiv.textContent = error.timestamp;
                errorDiv.appendChild(timestampDiv);
                
                // Error ID and severity
                const idDiv = document.createElement('div');
                idDiv.innerHTML = `<strong>ID:</strong> ${sanitizeText(error.id || (index + 1))} <strong>Severity:</strong> ${sanitizeText(error.severity || 'unknown').toUpperCase()}`;
                errorDiv.appendChild(idDiv);
                
                // Message
                const messageDiv = document.createElement('div');
                messageDiv.innerHTML = `<strong>Error:</strong> ${error.message || 'Unknown error'}`;
                errorDiv.appendChild(messageDiv);
                
                // File info
                const fileDiv = document.createElement('div');
                fileDiv.innerHTML = `<strong>File:</strong> ${sanitizeText(error.filename || error.url || 'unknown')}:${error.lineno || error.line || 0}:${error.colno || error.col || 0}`;
                errorDiv.appendChild(fileDiv);
                
                // Source
                if (error.source) {
                    const sourceDiv = document.createElement('div');
                    sourceDiv.innerHTML = `<strong>Source:</strong> ${sanitizeText(error.source)}`;
                    errorDiv.appendChild(sourceDiv);
                }
                
                // Stack trace (collapsible)
                if (error.stack && error.stack !== 'No stack trace') {
                    const stackHeaderDiv = document.createElement('div');
                    stackHeaderDiv.innerHTML = '<strong>Stack:</strong> <span style="cursor: pointer; color: #0ff;">[Toggle]</span>';
                    stackHeaderDiv.style.marginTop = '5px';
                    errorDiv.appendChild(stackHeaderDiv);
                    
                    const stackDiv = document.createElement('div');
                    stackDiv.style.cssText = 'color: #ff0; margin-left: 20px; font-size: 12px; white-space: pre-wrap; display: none; max-height: 150px; overflow-y: auto; background: #0a0a0a; padding: 5px; border-left: 2px solid #ff0;';
                    stackDiv.textContent = sanitizeStack(error.stack);
                    
                    let isVisible = false;
                    stackHeaderDiv.addEventListener('click', () => {
                        isVisible = !isVisible;
                        stackDiv.style.display = isVisible ? 'block' : 'none';
                        stackHeaderDiv.querySelector('span').textContent = isVisible ? '[Hide]' : '[Show]';
                    });
                    
                    errorDiv.appendChild(stackDiv);
                }
                
                errorList.appendChild(errorDiv);
            });
        }
        
        function startGame() {
            // Open game in new window/tab
            const gameWindow = window.open('/', '_blank');
            
            // Listen for secure error events
            window.addEventListener('secureErrorCaptured', () => {
                refreshErrors();
            });
            
            // Listen for storage events (fallback)
            window.addEventListener('storage', (e) => {
                if (e.key && (e.key.includes('error') || e.key.includes('secure'))) {
                    refreshErrors();
                }
            });
        }
        
        // Set up own error capture using secure handler
        if (secureErrorHandler) {
            // Errors will be automatically captured by the secure handler
            window.addEventListener('secureErrorCaptured', refreshErrors);
        } else {
            // Fallback error capture
            window.addEventListener('error', (e) => {
                console.warn('Fallback error capture:', e);
                refreshErrors();
            });
            
            window.addEventListener('unhandledrejection', (e) => {
                console.warn('Fallback promise rejection:', e);
                refreshErrors();
            });
        }
        
        // Make functions available globally
        window.clearErrors = clearErrors;
        window.refreshErrors = refreshErrors;
        window.startGame = startGame;
        
        // Initial load
        refreshErrors();
        
        // Auto-refresh every 3 seconds
        setInterval(refreshErrors, 3000);
        
        console.log('‚úÖ Secure Error Monitor initialized');
    </script>
</body>
</html>