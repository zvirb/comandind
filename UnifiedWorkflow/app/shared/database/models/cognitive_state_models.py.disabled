"""
SQLAlchemy models for unified cognitive state management in multi-agent systems.

This module defines the database schema for blackboard communication, episodic memory,
consensus memory, and multi-tiered memory storage required by the collaborative 
multi-agent framework.

Architecture:
- Immutable event stream for all agent communications
- Multi-tiered memory: private, shared, and consensus
- Knowledge graph for structured consensus storage
- Distributed agent synchronization and conflict resolution
"""

import enum
import uuid
from datetime import datetime
from typing import Any, Dict, List, Optional

from sqlalchemy import (
    Boolean,
    Enum as SQLAlchemyEnum,
    Float,
    ForeignKey,
    Integer,
    String,
    Text,
    DateTime,
    Index,
)
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.schema import UniqueConstraint
from sqlalchemy.sql import func

from shared.utils.database_setup import Base


class EventType(str, enum.Enum):
    """Types of events in the blackboard event stream."""
    AGENT_CONTRIBUTION = "agent_contribution"
    CONFLICT_DETECTED = "conflict_detected" 
    CONSENSUS_REACHED = "consensus_reached"
    TASK_DELEGATED = "task_delegated"
    MEMORY_UPDATED = "memory_updated"
    STATE_SYNCHRONIZED = "state_synchronized"
    VALIDATION_COMPLETED = "validation_completed"
    DECISION_MADE = "decision_made"
    GOAL_ESTABLISHED = "goal_established"
    PLAN_CREATED = "plan_created"


class Performative(str, enum.Enum):
    """Communication performatives for agent interactions."""
    INFORM = "inform"
    REQUEST = "request"
    PROPOSE = "propose"
    ACCEPT = "accept"
    REJECT = "reject"
    CONFIRM = "confirm"
    CANCEL = "cancel"
    QUERY = "query"
    ASSERT = "assert"
    RETRACT = "retract"


class MemoryTier(str, enum.Enum):
    """Memory access tiers for cognitive state storage."""
    PRIVATE = "private"      # Agent-specific private memory
    SHARED = "shared"        # Cross-agent shared context
    CONSENSUS = "consensus"  # Agreed-upon source of truth


class SynchronizationStatus(str, enum.Enum):
    """Status of cognitive state synchronization."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    CONFLICT = "conflict"


class ValidationStatus(str, enum.Enum):
    """Status of consensus validation."""
    UNVALIDATED = "unvalidated"
    VALIDATING = "validating"
    VALIDATED = "validated"
    REJECTED = "rejected"
    CONFLICTED = "conflicted"


class BlackboardEvent(Base):
    """
    Immutable event stream for blackboard communication system.
    
    Captures every communicative act between agents with full audit trail.
    Events are append-only and never modified after creation.
    """
    __tablename__ = "blackboard_events"
    
    # Primary identification
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    event_sequence: Mapped[int] = mapped_column(Integer, nullable=False, autoincrement=True, index=True)
    
    # Event metadata
    event_type: Mapped[EventType] = mapped_column(
        SQLAlchemyEnum(EventType, values_callable=lambda x: [e.value for e in x]), 
        nullable=False, index=True
    )
    performative: Mapped[Performative] = mapped_column(
        SQLAlchemyEnum(Performative, values_callable=lambda x: [e.value for e in x]), 
        nullable=False, index=True
    )
    
    # Agent context
    source_agent_id: Mapped[str] = mapped_column(String, nullable=False, index=True)
    target_agent_id: Mapped[Optional[str]] = mapped_column(String, nullable=True, index=True)
    agent_role: Mapped[str] = mapped_column(String, nullable=False, index=True)
    
    # User and session context
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False, index=True)
    session_id: Mapped[str] = mapped_column(String, nullable=False, index=True)
    conversation_id: Mapped[Optional[str]] = mapped_column(String, nullable=True, index=True)
    
    # Event content (JSON-LD structured format)
    event_payload: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False)
    semantic_context: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    
    # Causality and relationships
    parent_event_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        ForeignKey("blackboard_events.id"), nullable=True, index=True
    )
    causality_chain: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    related_events: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    
    # Temporal context
    logical_timestamp: Mapped[int] = mapped_column(Integer, nullable=False, index=True)
    processing_duration_ms: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    
    # Immutable timestamp
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False, index=True
    )
    
    # Relationships
    user: Mapped["User"] = relationship("User")
    parent_event: Mapped[Optional["BlackboardEvent"]] = relationship(
        "BlackboardEvent", remote_side=[id], backref="child_events"
    )
    
    # Table configuration
    __table_args__ = (
        Index('idx_blackboard_events_temporal', 'created_at', 'logical_timestamp'),
        Index('idx_blackboard_events_agent_session', 'source_agent_id', 'session_id'),
        Index('idx_blackboard_events_causality', 'parent_event_id', 'event_sequence'),
        Index('idx_blackboard_events_payload_gin', 'event_payload', postgresql_using='gin'),
    )


class AgentContextState(Base):
    """
    Agent-specific context storage for distributed cognitive state management.
    
    Supports private agent memory, session-specific context, and cross-agent
    shared context with automatic cleanup and synchronization.
    """
    __tablename__ = "agent_context_states"
    
    # Primary identification
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Agent identification
    agent_id: Mapped[str] = mapped_column(String, nullable=False, index=True)
    agent_type: Mapped[str] = mapped_column(String, nullable=False, index=True)
    agent_role: Mapped[str] = mapped_column(String, nullable=False, index=True)
    
    # Context scope
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False, index=True)
    session_id: Mapped[str] = mapped_column(String, nullable=False, index=True)
    memory_tier: Mapped[MemoryTier] = mapped_column(
        SQLAlchemyEnum(MemoryTier, values_callable=lambda x: [e.value for e in x]), 
        nullable=False, index=True
    )
    
    # Context data
    context_key: Mapped[str] = mapped_column(String, nullable=False)
    context_value: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False)
    context_metadata: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    
    # Access control
    is_shareable: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    access_permissions: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    
    # Lifecycle management
    expires_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    is_persistent: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    
    # Synchronization
    version: Mapped[int] = mapped_column(Integer, default=1, nullable=False)
    last_synchronized_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    sync_checksum: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False
    )
    
    # Relationships
    user: Mapped["User"] = relationship("User")
    
    # Table configuration
    __table_args__ = (
        UniqueConstraint('agent_id', 'session_id', 'context_key', name='_agent_session_context_uc'),
        Index('idx_agent_context_memory_tier', 'memory_tier', 'session_id'),
        Index('idx_agent_context_expiry', 'expires_at'),
        Index('idx_agent_context_value_gin', 'context_value', postgresql_using='gin'),
    )


class ConsensusMemoryNode(Base):
    """
    Knowledge graph entities representing agreed-upon consensus memory.
    
    Stores structured knowledge, established facts, goals, plans, and
    user requirements as part of the shared ontology system.
    """
    __tablename__ = "consensus_memory_nodes"
    
    # Primary identification
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Node identification
    node_type: Mapped[str] = mapped_column(String, nullable=False, index=True)
    node_key: Mapped[str] = mapped_column(String, nullable=False, index=True)
    
    # Content
    title: Mapped[str] = mapped_column(String, nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    content: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False)
    
    # Context
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False, index=True)
    session_id: Mapped[Optional[str]] = mapped_column(String, nullable=True, index=True)
    domain: Mapped[Optional[str]] = mapped_column(String, nullable=True, index=True)
    
    # Consensus tracking
    validation_status: Mapped[ValidationStatus] = mapped_column(
        SQLAlchemyEnum(ValidationStatus, values_callable=lambda x: [e.value for e in x]), 
        default=ValidationStatus.UNVALIDATED, nullable=False, index=True
    )
    consensus_score: Mapped[float] = mapped_column(Float, default=0.0, nullable=False)
    validation_count: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    
    # Source tracking
    source_events: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    contributing_agents: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    decision_rationale: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    # Semantic properties
    semantic_tags: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    importance_weight: Mapped[float] = mapped_column(Float, default=1.0, nullable=False)
    confidence_level: Mapped[float] = mapped_column(Float, default=0.5, nullable=False)
    
    # Lifecycle
    is_active: Mapped[bool] = mapped_column(Boolean, default=True, nullable=False)
    superseded_by: Mapped[Optional[uuid.UUID]] = mapped_column(
        ForeignKey("consensus_memory_nodes.id"), nullable=True
    )
    
    # Timestamps
    established_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    last_validated_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    user: Mapped["User"] = relationship("User")
    superseding_node: Mapped[Optional["ConsensusMemoryNode"]] = relationship(
        "ConsensusMemoryNode", remote_side=[id], backref="superseded_nodes"
    )
    
    # Table configuration
    __table_args__ = (
        UniqueConstraint('user_id', 'node_type', 'node_key', name='_user_consensus_node_uc'),
        Index('idx_consensus_memory_validation', 'validation_status', 'consensus_score'),
        Index('idx_consensus_memory_domain', 'domain', 'user_id'),
        Index('idx_consensus_memory_content_gin', 'content', postgresql_using='gin'),
        Index('idx_consensus_memory_tags_gin', 'semantic_tags', postgresql_using='gin'),
    )


class ConsensusMemoryRelation(Base):
    """
    Knowledge graph relationships between consensus memory nodes.
    
    Defines typed relationships with semantic properties for building
    a structured knowledge graph of consensus information.
    """
    __tablename__ = "consensus_memory_relations"
    
    # Primary identification
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Relationship definition
    source_node_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("consensus_memory_nodes.id"), nullable=False, index=True
    )
    target_node_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("consensus_memory_nodes.id"), nullable=False, index=True
    )
    relation_type: Mapped[str] = mapped_column(String, nullable=False, index=True)
    
    # Relationship properties
    properties: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    strength: Mapped[float] = mapped_column(Float, default=1.0, nullable=False)
    confidence: Mapped[float] = mapped_column(Float, default=1.0, nullable=False)
    
    # Context
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False, index=True)
    established_by_event: Mapped[Optional[uuid.UUID]] = mapped_column(
        ForeignKey("blackboard_events.id"), nullable=True
    )
    
    # Validation
    validation_status: Mapped[ValidationStatus] = mapped_column(
        SQLAlchemyEnum(ValidationStatus, values_callable=lambda x: [e.value for e in x]), 
        default=ValidationStatus.UNVALIDATED, nullable=False
    )
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    
    # Relationships
    user: Mapped["User"] = relationship("User")
    source_node: Mapped["ConsensusMemoryNode"] = relationship(
        "ConsensusMemoryNode", foreign_keys=[source_node_id], backref="outgoing_relations"
    )
    target_node: Mapped["ConsensusMemoryNode"] = relationship(
        "ConsensusMemoryNode", foreign_keys=[target_node_id], backref="incoming_relations"
    )
    establishing_event: Mapped[Optional["BlackboardEvent"]] = relationship("BlackboardEvent")
    
    # Table configuration
    __table_args__ = (
        UniqueConstraint('source_node_id', 'target_node_id', 'relation_type', name='_node_relation_uc'),
        Index('idx_consensus_relations_type', 'relation_type', 'strength'),
        Index('idx_consensus_relations_validation', 'validation_status'),
    )


class CognitiveStateSynchronization(Base):
    """
    Distributed consensus protocols for agent state alignment.
    
    Manages synchronization checkpoints, version control for consensus
    memory updates, and conflict resolution across distributed agents.
    """
    __tablename__ = "cognitive_state_synchronizations"
    
    # Primary identification
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Synchronization scope
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False, index=True)
    session_id: Mapped[str] = mapped_column(String, nullable=False, index=True)
    sync_scope: Mapped[str] = mapped_column(String, nullable=False, index=True)  # "session", "user", "global"
    
    # Synchronization details
    sync_type: Mapped[str] = mapped_column(String, nullable=False, index=True)  # "full", "incremental", "conflict_resolution"
    status: Mapped[SynchronizationStatus] = mapped_column(
        SQLAlchemyEnum(SynchronizationStatus, values_callable=lambda x: [e.value for e in x]), 
        default=SynchronizationStatus.PENDING, nullable=False, index=True
    )
    
    # Participating agents
    participating_agents: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    coordinator_agent: Mapped[str] = mapped_column(String, nullable=False)
    
    # Synchronization data
    state_snapshot: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False)
    conflicts_detected: Mapped[List[Dict[str, Any]]] = mapped_column(JSONB, nullable=False, default=list)
    resolution_strategy: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    
    # Version control
    source_version: Mapped[int] = mapped_column(Integer, nullable=False)
    target_version: Mapped[int] = mapped_column(Integer, nullable=False)
    checksum_before: Mapped[str] = mapped_column(String, nullable=False)
    checksum_after: Mapped[Optional[str]] = mapped_column(String, nullable=True)
    
    # Performance metrics
    processing_time_ms: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    conflict_count: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    resolution_count: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    
    # Error handling
    error_details: Mapped[Optional[Dict[str, Any]]] = mapped_column(JSONB, nullable=True)
    retry_count: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    
    # Timestamps
    initiated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    completed_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    user: Mapped["User"] = relationship("User")
    
    # Table configuration
    __table_args__ = (
        Index('idx_cognitive_sync_status', 'status', 'initiated_at'),
        Index('idx_cognitive_sync_session', 'session_id', 'sync_scope'),
        Index('idx_cognitive_sync_conflicts', 'conflict_count', 'status'),
        Index('idx_cognitive_sync_snapshot_gin', 'state_snapshot', postgresql_using='gin'),
    )


class SharedOntologyTerm(Base):
    """
    Formalized vocabulary and conceptual framework for semantic interoperability.
    
    Defines shared concepts, relationships, and terminology used across
    the multi-agent system for consistent communication and understanding.
    """
    __tablename__ = "shared_ontology_terms"
    
    # Primary identification
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Term definition
    term: Mapped[str] = mapped_column(String, nullable=False, index=True)
    namespace: Mapped[str] = mapped_column(String, nullable=False, index=True)
    term_type: Mapped[str] = mapped_column(String, nullable=False, index=True)  # "concept", "property", "relation"
    
    # Semantic definition
    definition: Mapped[str] = mapped_column(Text, nullable=False)
    synonyms: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    examples: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    
    # Hierarchical relationships
    parent_term_id: Mapped[Optional[uuid.UUID]] = mapped_column(
        ForeignKey("shared_ontology_terms.id"), nullable=True, index=True
    )
    semantic_properties: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False, default=dict)
    
    # Usage context
    applicable_domains: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    agent_types: Mapped[List[str]] = mapped_column(JSONB, nullable=False, default=list)
    
    # Governance
    is_core_term: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    approval_status: Mapped[str] = mapped_column(String, default="draft", nullable=False)
    version: Mapped[str] = mapped_column(String, default="1.0", nullable=False)
    
    # Usage tracking
    usage_count: Mapped[int] = mapped_column(Integer, default=0, nullable=False)
    last_used_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False
    )
    
    # Relationships
    parent_term: Mapped[Optional["SharedOntologyTerm"]] = relationship(
        "SharedOntologyTerm", remote_side=[id], backref="child_terms"
    )
    
    # Table configuration
    __table_args__ = (
        UniqueConstraint('namespace', 'term', name='_ontology_namespace_term_uc'),
        Index('idx_ontology_term_type', 'term_type', 'namespace'),
        Index('idx_ontology_usage', 'usage_count', 'last_used_at'),
        Index('idx_ontology_properties_gin', 'semantic_properties', postgresql_using='gin'),
        Index('idx_ontology_domains_gin', 'applicable_domains', postgresql_using='gin'),
    )


class QualityAssuranceCheckpoint(Base):
    """
    Quality assurance checkpoints and validations for cognitive state integrity.
    
    Tracks validation processes, integrity checks, and quality metrics
    for the cognitive state management system.
    """
    __tablename__ = "quality_assurance_checkpoints"
    
    # Primary identification
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    
    # Checkpoint context
    checkpoint_type: Mapped[str] = mapped_column(String, nullable=False, index=True)
    target_entity_type: Mapped[str] = mapped_column(String, nullable=False, index=True)
    target_entity_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), nullable=False, index=True)
    
    # User and session context
    user_id: Mapped[int] = mapped_column(ForeignKey("users.id"), nullable=False, index=True)
    session_id: Mapped[Optional[str]] = mapped_column(String, nullable=True, index=True)
    
    # Validation details
    validation_criteria: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False)
    validation_results: Mapped[Dict[str, Any]] = mapped_column(JSONB, nullable=False)
    overall_score: Mapped[float] = mapped_column(Float, nullable=False)
    
    # Status and outcome
    status: Mapped[ValidationStatus] = mapped_column(
        SQLAlchemyEnum(ValidationStatus, values_callable=lambda x: [e.value for e in x]), 
        default=ValidationStatus.UNVALIDATED, nullable=False, index=True
    )
    passed_validation: Mapped[bool] = mapped_column(Boolean, nullable=False)
    issues_found: Mapped[List[Dict[str, Any]]] = mapped_column(JSONB, nullable=False, default=list)
    
    # Processing details
    validator_agent: Mapped[str] = mapped_column(String, nullable=False)
    processing_time_ms: Mapped[int] = mapped_column(Integer, nullable=False)
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now(), nullable=False
    )
    completed_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)
    
    # Relationships
    user: Mapped["User"] = relationship("User")
    
    # Table configuration
    __table_args__ = (
        Index('idx_qa_checkpoint_type_status', 'checkpoint_type', 'status'),
        Index('idx_qa_checkpoint_target', 'target_entity_type', 'target_entity_id'),
        Index('idx_qa_checkpoint_score', 'overall_score', 'passed_validation'),
        Index('idx_qa_checkpoint_results_gin', 'validation_results', postgresql_using='gin'),
    )