{
    # Global configuration for dynamic DNS environments
    admin 0.0.0.0:2019
    
    # ACME settings for Let's Encrypt
    email {env.ACME_EMAIL}
    
    # Certificate issuer with DNS challenge preference
    cert_issuer acme {
        # Prefer DNS-01 challenge for dynamic DNS reliability
        disable_http_challenge
        disable_tlsalpn_challenge
        
        # DNS provider configuration (set via environment)
        dns {env.DNS_PROVIDER} {env.DNS_API_TOKEN}
        
        # Extended timeouts for DNS propagation
        propagation_timeout 300s
        polling_interval 10s
    }
    
    # Logging configuration
    log {
        output file /var/log/caddy/access.log
        format json
    }
}

# Main domain configuration
{env.DOMAIN} {
    # DNS-01 challenge for certificate
    tls {
        dns {env.DNS_PROVIDER} {env.DNS_API_TOKEN}
        
        # DNS resolvers for validation
        resolvers 1.1.1.1 8.8.8.8 8.8.4.4
        
        # Certificate settings
        key_type rsa2048
        must_staple
    }
    
    # Security headers
    header {
        # HSTS with preload
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
        
        # Prevent clickjacking
        X-Frame-Options "DENY"
        
        # Prevent MIME type sniffing
        X-Content-Type-Options "nosniff"
        
        # XSS protection
        X-XSS-Protection "1; mode=block"
        
        # Referrer policy
        Referrer-Policy "strict-origin-when-cross-origin"
        
        # Content Security Policy
        Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' https:; connect-src 'self' wss: https:;"
        
        # Remove server information
        -Server
    }
    
    # ACME challenge endpoint (backup for HTTP-01 if needed)
    handle /.well-known/acme-challenge/* {
        root * /var/www/html
        file_server
    }
    
    # WebSocket handling
    @websockets {
        header Connection *Upgrade*
        header Upgrade websocket
    }
    handle @websockets {
        reverse_proxy api:8000 {
            header_up Host {host}
            header_up X-Real-IP {remote_host}
            header_up X-Forwarded-For {remote_host}
            header_up X-Forwarded-Proto {scheme}
        }
    }
    
    # API routes
    handle /api/* {
        reverse_proxy api:8000 {
            # Health checking
            health_uri /health
            health_interval 30s
            health_timeout 10s
            health_status 2xx
            
            # Load balancing (for future scaling)
            lb_policy round_robin
            
            # Headers
            header_up Host {host}
            header_up X-Real-IP {remote_host}
            header_up X-Forwarded-For {remote_host}
            header_up X-Forwarded-Proto {scheme}
            header_up X-Forwarded-Port {server_port}
            
            # Timeouts
            transport {
                dial_timeout 10s
                response_header_timeout 10s
            }
        }
    }
    
    # Static file handling (if any)
    handle /static/* {
        root * /var/www/html
        file_server
    }
    
    # Default route - proxy to WebUI or main app
    handle {
        reverse_proxy webui:3000 {
            header_up Host {host}
            header_up X-Real-IP {remote_host}
            header_up X-Forwarded-For {remote_host}
            header_up X-Forwarded-Proto {scheme}
        }
    }
    
    # Error handling
    handle_errors {
        @maintenance_mode file /var/www/maintenance.html
        handle @maintenance_mode {
            root * /var/www
            rewrite * /maintenance.html
            file_server
        }
        
        respond "Service temporarily unavailable" 503
    }
    
    # Request/response logging
    log {
        output file /var/log/caddy/{env.DOMAIN}.log {
            roll_size 10MB
            roll_keep 10
            roll_keep_for 720h
        }
        format json {
            time_format "2006-01-02T15:04:05.000Z07:00"
            message_key "msg"
            level_key "level"
            time_key "@timestamp"
        }
        level INFO
    }
}

# HTTP to HTTPS redirect
http://{env.DOMAIN} {
    redir https://{env.DOMAIN}{uri} permanent
}

# Direct IP access handling (security measure)
:{env.SERVER_IP}:443 {
    tls internal
    
    respond "Direct IP access not allowed. Please use domain name: {env.DOMAIN}" 403 {
        header Content-Type "text/plain"
    }
}

# Health check endpoint for load balancers
:8080 {
    handle /health {
        respond "OK" 200
    }
    
    handle {
        respond "Health check endpoint" 200
    }
}

# Admin API security (restrict access)
:2019 {
    # Only allow local access to admin API
    @local_only {
        remote_ip 127.0.0.1/8 ::1/128 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16
    }
    
    handle @local_only {
        reverse_proxy 127.0.0.1:2019
    }
    
    handle {
        respond "Access denied" 403
    }
}